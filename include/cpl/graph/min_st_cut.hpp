//          Copyright Diego Ram√≠rez August 2015
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#ifndef CPL_GRAPH_MIN_ST_CUT_HPP
#define CPL_GRAPH_MIN_ST_CUT_HPP

#include <cpl/graph/edmonds_karp_max_flow.hpp>

#include <stack>   // for std::stack
#include <utility> // for std::declval
#include <vector>  // for std::vector
#include <cstddef> // for std::size_t

namespace cpl {

/// \brief Finds the minimum s-t cut in the given graph.
///
/// A s-t cut determines a s-t cut-set. A s-t cut-set is a set of edges that
/// when removed from the graph make the maximum flow from \p source to \p
/// target equal to 0. A minimum s-t cut is any s-t cut which minimizes the
/// total sum of edge's weights in the cut-set.
///
/// This algorithm uses the Edmonds-Karp maximum flow algorithm to determine the
/// weight of the min s-t cut as its value is equal to the max-flow from \p
/// source to \p target (See max-flow min-cut theorem).
///
/// The \p source_side output parameter is used to record the reachable vertices
/// from \p source through the residual graph (generated by the max-flow
/// algorithm). All edges going from reachable (source side) vertices to
/// unreachable (non source side) vertices form part of the s-t cut-set.
///
/// \param g The target graph.
/// \param source Descriptor of the source vertex.
/// \param target Descriptor of the target vertex.
/// \param rev_edge The reverse-edge map to be used in the max-flow algorithm.
/// \param capacity The capacity map to be used in the max-flow algorithm.
/// \param[out] source_side Map vector, it will be resized to the number of
/// vertices in the graph and modified in such a way that \c source_side[v]
/// evaluates to \c true iff the vertex \c v is reachable from \p source through
/// the residual graph.
///
/// \returns The weight of the min s-t cut.
///
/// \pre <tt>source != target</tt>
///
/// \par Complexity
/// Same as the underlying max-flow algorithm. In this case:
/// <tt>O(V * E^2)</tt> (See Edmonds-Karp max-flow for details).
///
template <typename Graph, typename Flow>
Flow min_st_cut(const Graph &g, const size_t source, const size_t target,
                const std::vector<size_t> &rev_edge,
                const std::vector<Flow> &capacity,
                std::vector<bool> &source_side) {

  std::vector<Flow> residual;
  const auto max_flow =
      edmonds_karp_max_flow(g, source, target, rev_edge, capacity, residual);

  source_side.assign(g.num_vertices(), false);
  std::stack<size_t> stack;

  source_side[source] = true;
  stack.push(source);
  while (!stack.empty()) {
    const size_t current = stack.top();
    stack.pop();
    for (const auto edge : g.out_edges(current)) {
      const size_t neighbor = g.target(edge);
      if (source_side[neighbor])
        continue; // Already discovered.
      if (!residual[edge])
        continue; // Can't navigate through saturated edges.
      source_side[neighbor] = true;
      stack.push(neighbor);
    }
  }
  return max_flow;
}

} // end namespace cpl

#endif // Header guard
